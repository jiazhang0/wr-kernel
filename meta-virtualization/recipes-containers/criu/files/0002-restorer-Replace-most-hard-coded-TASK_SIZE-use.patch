From 7451fc7d2385fcebdbd907ecda903f087c8e7273 Mon Sep 17 00:00:00 2001
From: Christopher Covington <cov@codeaurora.org>
Date: Fri, 31 Jul 2015 10:36:25 -0400
Subject: [PATCH 2/4] restorer: Replace most hard-coded TASK_SIZE use

If we want one CRIU binary to work across all AArch64 kernel
configurations, a single task size value cannot be hard coded.
This fixes the following error on AArch64 kernels with
CONFIG_ARM64_64K_PAGES=y.

  pie: Error (pie/restorer.c:772): Unable to unmap (-): -1211695104

Signed-off-by: Christopher Covington <cov@codeaurora.org>
Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
---
 cr-restore.c       |  2 ++
 include/restorer.h |  1 +
 pie/restorer.c     | 17 +++++++++--------
 3 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/cr-restore.c b/cr-restore.c
index cec3104..a475802 100644
--- a/cr-restore.c
+++ b/cr-restore.c
@@ -2893,6 +2893,8 @@ static int sigreturn_restore(pid_t pid, CoreEntry *core)
 	task_args->premmapped_addr = (unsigned long)rsti(current)->premmapped_addr;
 	task_args->premmapped_len = rsti(current)->premmapped_len;
 
+	task_args->task_size = kdat.task_size;
+
 #define remap_array(name, nr, cpos)	do {				\
 		task_args->name##_n = nr;				\
 		task_args->name = rst_mem_remap_ptr(cpos, RM_PRIVATE);	\
diff --git a/include/restorer.h b/include/restorer.h
index 97a012c..56b9938 100644
--- a/include/restorer.h
+++ b/include/restorer.h
@@ -139,6 +139,7 @@ struct task_restore_args {
 	unsigned int			zombies_n;
 	/* * * * * * * * * * * * * * * * * * * * */
 
+	unsigned long			task_size;
 	unsigned long			premmapped_addr;
 	unsigned long			premmapped_len;
 	rt_sigaction_t			sigchld_act;
diff --git a/pie/restorer.c b/pie/restorer.c
index d84a5c0..3e582cc 100644
--- a/pie/restorer.c
+++ b/pie/restorer.c
@@ -727,16 +727,17 @@ void __export_unmap(void)
  * and arguments and the one with private vmas of the tasks we restore
  * (a.k.a. premmaped area):
  *
- * 0                       TASK_SIZE
+ * 0                       task_size
  * +----+====+----+====+---+
  *
  * Thus to unmap old memory we have to do 3 unmaps:
  * [ 0 -- 1st area start ]
  * [ 1st end -- 2nd start ]
- * [ 2nd start -- TASK_SIZE ]
+ * [ 2nd start -- task_size ]
  */
 static int unmap_old_vmas(void *premmapped_addr, unsigned long premmapped_len,
-		      void *bootstrap_start, unsigned long bootstrap_len)
+		      void *bootstrap_start, unsigned long bootstrap_len,
+		      unsigned long task_size)
 {
 	unsigned long s1, s2;
 	void *p1, *p2;
@@ -766,10 +767,10 @@ static int unmap_old_vmas(void *premmapped_addr, unsigned long premmapped_len,
 		return -1;
 	}
 
-	ret = sys_munmap(p2 + s2, (void *) TASK_SIZE - (p2 + s2));
+	ret = sys_munmap(p2 + s2, task_size - (unsigned long)(p2 + s2));
 	if (ret) {
 		pr_err("Unable to unmap (%p-%p): %d\n",
-				p2 + s2, (void *)TASK_SIZE, ret);
+				p2 + s2, (void *)task_size, ret);
 		return -1;
 	}
 
@@ -870,7 +871,7 @@ long __export_restore_task(struct task_restore_args *args)
 		goto core_restore_end;
 
 	if (unmap_old_vmas((void *)args->premmapped_addr, args->premmapped_len,
-				bootstrap_start, bootstrap_len))
+				bootstrap_start, bootstrap_len, args->task_size))
 		goto core_restore_end;
 
 	/* Shift private vma-s to the left */
@@ -880,7 +881,7 @@ long __export_restore_task(struct task_restore_args *args)
 		if (!vma_entry_is_private(vma_entry))
 			continue;
 
-		if (vma_entry->end >= TASK_SIZE)
+		if (vma_entry->end >= args->task_size)
 			continue;
 
 		if (vma_entry->start > vma_entry->shmid)
@@ -898,7 +899,7 @@ long __export_restore_task(struct task_restore_args *args)
 		if (!vma_entry_is_private(vma_entry))
 			continue;
 
-		if (vma_entry->start > TASK_SIZE)
+		if (vma_entry->start > args->task_size)
 			continue;
 
 		if (vma_entry->start < vma_entry->shmid)
-- 
1.9.1

